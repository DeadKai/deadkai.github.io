<!DOCTYPE html>
<html>
<head>
    
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://deadkai.github.io/atom.xml">
    
    
    
        
    
    
    
    
    
    
        
        
    
    
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <title>Understanding Rust&#x27;s Ownership System - title</title>
    <meta charset="utf-8">
    <meta name="title" content="Understanding Rust&#x27;s Ownership System - title">
    <meta name="description" content="">
    <meta property="og:image:width" content="200" />
    <meta property="og:image:height" content="200" />
    <link rel="stylesheet" href="https:&#x2F;&#x2F;deadkai.github.io/style.css">
    
    <link rel="stylesheet" href="https:&#x2F;&#x2F;deadkai.github.io/autodarkmode.css">
    
    
    <style>
    @media screen and (min-width: 320px) {
        body {
            font-size: calc(16px + 2 * ((100vw - 320px) / 960));
        }
    }
    </style>
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:wght@400;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;700&amp;family=Noto+Serif+KR:wght@400;700&amp;Noto+Serif+SC:wght@400;700&display=swap">
    <style>body { font-family: 'Source Serif Pro', 'Source Han Serif TC', 'Noto Serif CJK TC', 'Noto Serif TC', 'Noto Serif KR', 'Noto Serif SC', serif }</style>
    

    <!-- MathJax Latex Support Script-->
    

</head>
<body>
    
    <header class="header">
        <div class="blog-title"><a href="https:&#x2F;&#x2F;deadkai.github.io" class="logo">title</a></div>
        <nav class="navbar">
    <ul class="menu">
        
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;deadkai.github.io&#x2F;" class="menu-item-link">home</a>
            
        </li>
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;deadkai.github.io&#x2F;archives" class="menu-item-link">archives</a>
            
        </li>
        
        <li class="menu-item">
            
            
            
            
            <a href="https:&#x2F;&#x2F;deadkai.github.io&#x2F;about" class="menu-item-link">about</a>
            
        </li>
        
    </ul>
</nav>

    </header>
    
    <main class="main">
        
<article class="post">
    <div class="post-title">
        <h1 class="title">Understanding Rust&#x27;s Ownership System</h1>
    </div>
    <div class="post-content">
        <p>Rust's ownership system is one of its most distinctive features, enabling memory safety without garbage collection. This system is built on three key rules that the compiler enforces at compile time.</p>
<h2 id="the-three-rules-of-ownership">The Three Rules of Ownership</h2>
<ol>
<li><strong>Each value in Rust has a variable that's called its owner</strong></li>
<li><strong>There can only be one owner at a time</strong></li>
<li><strong>When the owner goes out of scope, the value will be dropped</strong></li>
</ol>
<h2 id="why-ownership-matters">Why Ownership Matters</h2>
<p>Traditional systems programming languages like C and C++ require manual memory management, leading to common bugs like use-after-free, double-free, and memory leaks. Garbage-collected languages solve this but introduce runtime overhead and unpredictable pause times.</p>
<p>Rust's ownership system provides a third way: memory safety guarantees at compile time with zero runtime cost.</p>
<h2 id="ownership-in-practice">Ownership in Practice</h2>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> s1 = String::from(&quot;</span><span style="color:#a3be8c;">hello</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> s2 = s1; </span><span style="color:#65737e;">// s1 is moved to s2
</span><span>
</span><span>    </span><span style="color:#65737e;">// println!(&quot;{}&quot;, s1); // This would error! s1 is no longer valid
</span><span>    println!(&quot;</span><span style="color:#d08770;">{}</span><span>&quot;, s2); </span><span style="color:#65737e;">// This works fine
</span><span>}
</span></code></pre>
<p>When <code>s1</code> is assigned to <code>s2</code>, Rust doesn't copy the data. Instead, it moves ownership from <code>s1</code> to <code>s2</code>. This prevents double-free errors when both variables go out of scope.</p>
<h2 id="borrowing-and-references">Borrowing and References</h2>
<p>To use a value without taking ownership, Rust provides borrowing through references:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">calculate_length</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;String) -&gt; </span><span style="color:#b48ead;">usize </span><span>{
</span><span>    s.</span><span style="color:#96b5b4;">len</span><span>()
</span><span>} </span><span style="color:#65737e;">// s goes out of scope, but since it doesn&#39;t own the data, nothing happens
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let</span><span> s1 = String::from(&quot;</span><span style="color:#a3be8c;">hello</span><span>&quot;);
</span><span>    </span><span style="color:#b48ead;">let</span><span> len = </span><span style="color:#96b5b4;">calculate_length</span><span>(&amp;s1);
</span><span>    println!(&quot;</span><span style="color:#a3be8c;">Length of &#39;</span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">&#39; is </span><span style="color:#d08770;">{}</span><span style="color:#a3be8c;">.</span><span>&quot;, s1, len);
</span><span>}
</span></code></pre>
<p>The <code>&amp;</code> symbol creates a reference, allowing the function to borrow the value without taking ownership.</p>
<h2 id="mutable-references">Mutable References</h2>
<p>References are immutable by default, but you can create mutable references:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">main</span><span>() {
</span><span>    </span><span style="color:#b48ead;">let mut</span><span> s = String::from(&quot;</span><span style="color:#a3be8c;">hello</span><span>&quot;);
</span><span>    </span><span style="color:#96b5b4;">change</span><span>(&amp;</span><span style="color:#b48ead;">mut</span><span> s);
</span><span>}
</span><span>
</span><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">change</span><span>(</span><span style="color:#bf616a;">s</span><span>: &amp;</span><span style="color:#b48ead;">mut</span><span> String) {
</span><span>    s.</span><span style="color:#96b5b4;">push_str</span><span>(&quot;</span><span style="color:#a3be8c;">, world</span><span>&quot;);
</span><span>}
</span></code></pre>
<p>However, Rust enforces a crucial restriction: you can have either one mutable reference OR any number of immutable references at a time, but not both. This prevents data races at compile time.</p>
<h2 id="the-lifetime-system">The Lifetime System</h2>
<p>Lifetimes are Rust's way of ensuring that references are always valid. The compiler uses lifetime annotations to verify that references don't outlive the data they point to:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#c0c5ce;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#b48ead;">fn </span><span style="color:#8fa1b3;">longest</span><span>&lt;</span><span style="color:#b48ead;">&#39;a</span><span>&gt;(</span><span style="color:#bf616a;">x</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>, </span><span style="color:#bf616a;">y</span><span>: &amp;</span><span style="color:#b48ead;">&#39;a str</span><span>) -&gt; &amp;</span><span style="color:#b48ead;">&#39;a str </span><span>{
</span><span>    </span><span style="color:#b48ead;">if</span><span> x.</span><span style="color:#96b5b4;">len</span><span>() &gt; y.</span><span style="color:#96b5b4;">len</span><span>() {
</span><span>        x
</span><span>    } </span><span style="color:#b48ead;">else </span><span>{
</span><span>        y
</span><span>    }
</span><span>}
</span></code></pre>
<p>The <code>'a</code> annotation tells Rust that the returned reference will be valid as long as both input references are valid.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Rust's ownership system might seem complex at first, but it provides powerful guarantees that eliminate entire categories of bugs. By understanding these concepts, you can write safe, concurrent code without the overhead of garbage collection.</p>
<p>The learning curve is steep, but the payoff is substantial: fearless concurrency and memory safety guaranteed at compile time.</p>

    </div>
</article>

<div class="prev_next">
<nav id="prev_next">
    <div class="prev">
        
    </div>
    <div class="next">
        
    </div>
</nav>
</div>

<div class="post-comment">




</div>

    </main>
    
    <p class="license"></p>
    
</body>
</html>
